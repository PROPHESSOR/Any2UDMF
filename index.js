// Copyright (c) 2018 PROPHESSOR
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

'use strict';

const fs = require('fs');

const MapParser = require('./MapParser');

const [
	Linedef,
	Sector,
	Sidedef,
	Vertex
] = [
	require('./structures/linedef'),
	require('./structures/sector'),
	require('./structures/sidedef'),
	require('./structures/vertex')
];

const _Sector = require('./classes/Sector');
const Vec3 = require('./structures/Vec3');

const TEXTMAP = 'output/TEXTMAP';

const Map = {'sectors': []};

/** Парсит плейн на вектора
 * @param  {string} plane
 * @returns {Array} [Vec3, Vec3, Vec3]
 */
function parsePlane(plane) {
    const json = '[' + plane
        .replace(/\s/g, ', ')
        .replace(/\(/g, '[')
        .replace(/\)/g, ']')
        + ']';

    try {
        return JSON.parse(json);
    } catch (e) {
        return [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
    }
}


function parseMap() {
	MapParser('map');
	const map = require('./input/map.json');
	const brushes = map.array;

	for (const brush of brushes) {
		for (const side of brush.array) {
			const plane = parsePlane(side.plane);

			console.log(`plane: ${plane}`);
			Map.sectors.push(
				new _Sector(
					new Vec3(...plane[0]),
					new Vec3(...plane[1]),
					new Vec3(...plane[2])
				)
			);
		}
	}

	let startvertex = 0;

	for (const sector of Map.sectors) { // TODO: В 1 цикл
		sector.startvertex = startvertex;
		startvertex += 6;
	}
}

function parseVertexes() {
	const vertexes = [];

	for (const sector of Map.sectors) {
		let plus = 0;

		for (const line of sector.lines) {
			for (const vertex of line) {
				vertexes.push(new Vertex(sector.startvertex + plus, ...vertex));
				plus++;
			}
		}
	}

	let outstring = '// Vertexes\n';

	for (const vertex of vertexes) {
		console.log(`Vertex: ${vertex.toString()}`);
		outstring += vertex.toString();
	}

	return outstring;
}

function parseSectors() {
	const sectors = [];

	let secno = 0;

	for (const sector of Map.sectors) {
		sectors.push(new Sector(secno, sector.height, sector.height + 128, '-', '-', 255, 0, 0));
		secno++;
	}

	let outstring = '// Sectors\n';

	for (const sector of sectors) {
		console.log(sector.toString());
		outstring += sector.toString();
	}

	return outstring;
}

function parseLinedefs() {
	const linedefs = [];

	let lineno = 0;

	for (const sector of Map.sectors) {
		let plus = 0;

		for (const line of sector.lines) {
			linedefs.push(new Linedef(lineno, sector.startvertex + plus, sector.startvertex + plus + 1, 0, 0, 0, 0, 0));
			plus += 2;
			lineno++;
		}
	}

	let outstring = '// LineDefs\n';

	for (const linedef of linedefs) {
		console.log(linedef.toString());
		outstring += linedef.toString();
	}

	return outstring;
}

function parseSidedefs() {
	const sidedefs = [];

	let secno = 0;
	let lineno = 0;

	for (const sector of Map.sectors) {
		for (const line of sector.lines) {
			sidedefs.push(new Sidedef(lineno, 0, 0, '-', '-', '-', secno));
			lineno++;
		}
		secno++;
	}

	let outstring = '// SideDefs\n';

	for (const sidedef of sidedefs) {
		console.log(sidedef.toString());
		outstring += sidedef.toString();
	}

	return outstring;
}

let output = '// Generated by Any2UDMF\n\nnamespace = "ZDoom";\n';


parseMap();
output += parseVertexes();
output += parseLinedefs();
output += parseSidedefs();
output += parseSectors();
output += '\n\n// End of file';

fs.writeFileSync(TEXTMAP, output, 'utf8');